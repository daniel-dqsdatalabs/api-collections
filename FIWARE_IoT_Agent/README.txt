This tutorial introduces the concept of an **IoT Agent** and wires up the dummy [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) IoT devices created in the
[previous tutorial](https://github.com/Fiware/tutorials.IoT-Sensors) so that measurements can be read 
and commands can be sent using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) requests sent to the [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/).

The `docker-compose` files for this tutorial can be found on GitHub: 

![GitHub](https://fiware.github.io/tutorials.Historic-Context/icon/GitHub-Mark-32px.png) [FIWARE 202: Provisioning an IoT Agent](https://github.com/Fiware/tutorials.IoT-Agent)

# What is an IoT Agent?

> "In every operation there is an above the line and a below the line.
> Above the line is what you do by the book. Below the line is how you
> do the job."
>
> — John le Carré (A Perfect Spy)

An IoT Agent is a component that lets a group of devices send their data to and be managed from a Context Broker
using their own native protocols. IoT Agents should also be able to deal with security aspects of the Fiware 
platform (authentication and authorization of the channel) and provide other common services to the device programmer.

The Orion Context Broker exclusively uses [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) requests for all
of its interactions. Each IoT Agent provides a **North Port** [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)
interface which is used for context broker interactions and all interactions beneath this port occur using the **native protocol**
of the attached devices. 

In effect, this brings a standard interface to all IoT interactions at the context information management level. 
Each group of IoT devices are able to use their own propriatory protocols and disparate transport mechanisms under
the hood whilst the associated IoT Agent offers a facade pattern to handle this complexity.

IoT Agents already exist or are in development for many common transports and protocols. Examples include the following: 

* [IoTAgent-JSON](http://fiware-iotagent-json.readthedocs.io/en/latest/) (HTTP/MQTT transport) - a bridge between an HTTP/MQTT+JSON based protocol and NGSI
* [IoTAgent-LWM2M](http://fiware-iotagent-lwm2m.readthedocs.io/en/latest)  (CoaP transport) - a bridge between the Lightweight M2M protocol and NGSI
* [IoTAgent-UL](http://fiware-iotagent-ul.readthedocs.io/en/latest) (HTTP/MQTT transport) -  a bridge between the UltraLight2.0 protocol and NGSI 
* [IoTagent-LoraWAN](http://fiware-lorawan.readthedocs.io/en/latest) (CoaP transport) -  a bridge between the LoraWAN protocol and NGSI

## Southbound Traffic (Commands)

HTTP requests generated by the from the Context Broker and passed downwards towards an IoT device (via
an IoT agent) are known as southbound traffic. Southbound traffic consists of **commands** made to 
actuator devices which alter the state of the real world by their actions.  

For example to switch on a real-life UltraLight 2.0 **Smart Lamp** the following interactions would occur:

1. An request is sent to the **Context broker** to invoke the `on` command of the **Smart Lamp** via NGSI
2. The **Context Broker** finds the entity within the context and notes that the context provision for this 
  attribute has been delegated to the IoT Agent
3. The **Context broker** sends an NGSI request to the North Port of the **IoT Agent** to invoke the command
4. The **IoT Agent** receives this Southbound request and converts it to UltraLight 2.0 syntax and passes it on to the **Smart Lamp** 
5. The **Smart Lamp** switches on the lamp and returns the result of the command to the **IoT Agent** in UltraLight 2.0 syntax
6. The **IoT Agent** receives this Northbound request, interprets it and passes the result of the interaction into
  the context by making an NGSI request to the **Context Broker**.
6. The **Context Broker** receives this Northbound request and updates the context with the result of the command.


![](https://fiware.github.io/tutorials.IoT-Agent/img/command-swimlane.png)

* Requests between **User** and **Context Broker**  use NGSI
* Requests between **Context Broker** and **IoT Agent** use NGSI
* Requests between **IoT Agent** and **IoT Device** use native protocols
* Requests between **IoT Device** and **IoT Agent** use native protocols
* Requests between **IoT Agent** and **Context Broker** use NGSI


## Northbound Traffic (Measurements)

Requests generated from an IoT device and passed back upwards towards the Context Broker (via an 
IoT agent) are known as northbound traffic. Northbound traffic consists of **measurements** made
by sensor devices and relays the state of the real world into the context data of the system.

For example for a real-life **Motion Sensor** to send a count measurement the following interactions would occur:

1. A **Motion Sensor** makes a measurement and passes the result to the **IoT Agent**
2. The **IoT Agent** receives this Northbound request, converts the result from UltraLight syntax
  and passes the result of the interaction into the context by making an NGSI request to the **Context Broker**.
3. The **Context Broker** receives this Northbound request and updates the context with the result of the measurement. 


![](https://fiware.github.io/tutorials.IoT-Agent/img/measurement-swimlane.png)

* Requests between **Iot-Device** and **IoT-Agent** use native protocols
* Requests between **Iot-Agent** and **Context-Broker** use NGSI

> **Note** Other more complex interactions are also possible, but this overview is sufficient to understand the basic
> principles of an IoT Agent.

## Common Functionality

As can be seen from the previous sections, although each IoT Agent will be unique since they interpret different
protocols, there will a large degree of similarity between IoT agents. 

* Offering a standard location to listen to device updates
* Offering a standard location to listen to context data updates
* Holding a list of devices and mapping context data attributes to device syntax
* Security Authorization

This base functionality has been abstracted out into a common [IoT Agent framework library](https://fiware-iotagent-node-lib.readthedocs.org)

#### Device Monitor

For the purpose of this tutorial, a series of dummy IoT devices have been created, which will be attached to the context broker.
The state of each device can be seen on the UltraLight device monitor web-page found at: `http://localhost:3000/device/monitor`

![FIWARE Monitor](https://fiware.github.io/tutorials.IoT-Agent/img/device-monitor.png)

# Architecture

This application builds on the components created in [previous tutorials](https://github.com/Fiware/tutorials.Subscriptions/). It
will make use of two FIWARE components - the [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) and the [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/). Usage of the Orion Context Broker is sufficient for an application to qualify as *“Powered by FIWARE”*.
Both the Orion Context Broker and the IoT Agent rely on open source [MongoDB](https://www.mongodb.com/) technology to keep persistence of the information they hold. We will also be using the dummy IoT devices created in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Sensors/) 


Therefore the overall architecture will consist of the following elements:

* The FIWARE [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) which will receive requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)
* The FIWARE [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/) which will receive southbound requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) and convert them to  [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) commands for the devices
* The underlying [MongoDB](https://www.mongodb.com/) database :
  + Used by the **Orion Context Broker** to hold context data information such as data entities, subscriptions and registrations
  + Used by the **IoT Agent** to hold device information such as device URLs and Keys
* The **Context Provider NGSI** proxy is not used in this tutorial. It does the following:
  + receive requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)
  + makes requests to publicly available data sources using their own APIs in a proprietory format 
  + returns context data back to the Orion Context Broker in [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) format.
* The **Stock Management Frontend**  is not used in this tutorial will it does the following:
  + Display store information
  + Show which products can be bought at each store
  + Allow users to "buy" products and reduce the stock count.
* A webserver acting as set of [dummy IoT devices]](https://github.com/Fiware/tutorials.IoT-Sensors) using the [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) protocol running over HTTP.

Since all interactions between the elements are initiated by HTTP requests, the entities can be containerized and run from exposed ports. 

![](https://fiware.github.io/tutorials.IoT-Agent/img/architecture.png)

The necessary configuration information for wiring up the IoT devices and the IoT Agent can be seen in the services section of the associated `docker-compose.yml`  file:

## Dummy IoT Devices Configuration

```yaml
  context-provider:
    image: fiware/cp-web-app:latest
    hostname: context-provider
    container_name: context-provider
    networks:
        - default
    expose:
        - "3000"
        - "3001"
    ports:
        - "3000:3000"
        - "3001:3001"
    environment:
        - "DEBUG=proxy:*"
        - "PORT=3000"
        - "IOTA_HTTP_HOST=iot-agent"
        - "IOTA_HTTP_PORT=7896"
        - "DUMMY_DEVICES_PORT=3001"
        - "DUMMY_DEVICES_API_KEY=4jggokgpepnvsb2uv4s40d59ov"
```

The `context-provider` container is listening on two ports: 

* Port `3000` is exposed so we can see the web-page displaying the Dummy IoT devices.
* Port `3001` is exposed purely for tutorial access - so that cUrl or Postman can make UltraLight commands
  without being part of the same network.


The `context-provider` container is driven by environment variables as shown:

| Key |Value|Description|
|-----|-----|-----------|
|DEBUG|`proxy:*`| Debug flag used for logging |
|PORT|`3000`|Port used by web-app which displays the dummy device data |
|IOTA_HTTP_HOST|`iot-agent`| The host name of the IoT Agent for UltraLight 2.0 - see below | 
|IOTA_HTTP_PORT|`7896` | The port that the IoT Agent for UltraLight 2.0 will be listening on. `7896` is a common default for UltraLight over HTTP |
|DUMMY_DEVICES_PORT|`3001`|Port used by the dummy IoT devices to receive commands |
|DUMMY_DEVICES_API_KEY|`4jggokgpepnvsb2uv4s40d59ov`| Random security key used for UltraLight interactions - used to ensure the integrity of interactions between the devices and the IoT Agent |

The other `context-provider` container configuration values described in the YAML file are not used in this tutorial.

## IoT Agent for UltraLight 2.0 Configuration

The [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/)  can be instantiated within a Docker container. An offical Docker image is available from [Docker Hub](https://hub.docker.com/r/fiware/iotagent-ul/) tagged `fiware/iotagent-ul`. The 
necessary configuration can be seen below:

```yaml
  iot-agent:
    image: fiware/iotagent-ul:latest
    hostname: iot-agent
    container_name: iot-agent
    depends_on:
      - context-db
      - orion
    networks:
        - default
    expose:
        - "4041"
        - "7896"
    ports:
        - "4041:4041"
        - "7896:7896"
    environment:
        - "IOTA_CB_HOST=orion"
        - "IOTA_CB_PORT=1026"
        - "IOTA_NORTH_PORT=4041"
        - "IOTA_REGISTRY_TYPE=mongodb"
        - "IOTA_LOG_LEVEL=DEBUG"
        - "IOTA_TIMESTAMP=true"
        - "IOTA_MONGO_HOST=context-db"
        - "IOTA_MONGO_PORT=27017"
        - "IOTA_MONGO_DB=iotagentul"
        - "IOTA_HTTP_PORT=7896"
        - "IOTA_PROVIDER_URL=http://iot-agent:4041"
```

The `iot-agent` container relies on the precence of the Orion Context Broker and uses a MongoDB database to hold device information such as device URLs and Keys. The container is listening on two ports: 

* Port `7896` is exposed to receive Ultralight measurements over HTTP from the Dummy IoT devices
* Port `4041` is exposed purely for tutorial access - so that cUrl or Postman can make provisioning commands
  without being part of the same network.


The `iot-agent` container is driven by environment variables as shown:

| Key |Value|Description|
|-----|-----|-----------|
|IOTA_CB_HOST|`orion`| Hostname of the context broker to update context |
|IOTA_CB_PORT|`1026`| Port that context broker listens on to update context |
|IOTA_NORTH_PORT|`4041` | Port used for Configuring the IoT Agent and receiving context updates from the context broker |
|IOTA_REGISTRY_TYPE|`mongodb`| Whether to hold IoT device info in memory or in a database |
|IOTA_LOG_LEVEL|`DEBUG`|The log level of the IoT Agent |
|IOTA_TIMESTAMP|`true`| Whether to supply timestamp information with each measurement received from attached devices |
|IOTA_MONGO_HOST|`context-db`| The host name of mongoDB - used for holding device information |
|IOTA_MONGO_PORT|`27017`| The port mongoDB is listening on |
|IOTA_MONGO_DB|`iotagentul`| The name of the database used in mongoDB |
|IOTA_HTTP_PORT|`7896`| The port where the IoT Agent listens for IoT device traffic over HTTP |
|IOTA_PROVIDER_URL|`http://iot-agent:4041`| URL passed to the Context Broker when commands are registered, used as a forwarding URL location when the Context Broker issues a command to a device | 