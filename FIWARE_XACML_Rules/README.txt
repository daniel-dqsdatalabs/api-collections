[![FIWARE Security](https://nexus.lab.fiware.org/repository/raw/public/badges/chapters/security.svg)](https://www.fiware.org/developers/catalogue/)

This tutorial introduces an additional security generic enabler - **Authzforce**
and adds fine grained control to the security rules generated by **Keyrock**.
Access to the entities created in the
[previous tutorial](https://github.com/Fiware/tutorials.PEP-Proxy) is now
configured and controlled using an XACML access control policy - this creates a
flexible ruleset which can be uploaded and reinterpreted on the fly so complex
business rules can be created and changed according to current circumstances.

The tutorial discusses code showing how to integrate **Authzforce** within a web
application and demonstrates examples of **Authzforce** XACML Server-PDP
interactions. [cUrl](https://ec.haxx.se/) commands are used to show the
interactions between generic enablers.

The `docker-compose` files for this tutorial can be found on GitHub: 

![GitHub](https://fiware.github.io/tutorials.XACML-Access-Rules/icon/GitHub-Mark-32px.png) [FIWARE 405: Ruleset Based Permissions](https://github.com/Fiware/tutorials.XACML-Access-Rules)


# Ruleset Based Permissions

> "Say: Come, I will rehearse what _Allah_ hath prohibited you from:
>
> -   Join not anything as equal with _Him_
> -   Be good to your parents
> -   Kill not your children on a plea of want - _We_ provide sustenance for you
>     and for them
> -   Come not nigh to shameful deeds. Whether open or secret
> -   Take not life, which _Allah_ hath made sacred, except by way of justice
>     and law
>
> thus doth _He_ command you, that ye may learn wisdom."
>
> — Quran 6.151, Sūrat al-Anʻām

[Previous tutorials](https://github.com/Fiware/tutorials.Securing-Access) have
introduced a simple access control system based on authentication (level 1) or
basic authorization access to resources based on a role (level 2). These
policies are easy to create, but the rules within them are very black and white,
rules cannot rely on one another, have exception clauses or offer access based
on time limits or attribute values. There is also no mechanism to resolve
different rules in the case of conflict.

To satisfy a complex access control scenario, an additional arbitration
microservice is required, which is able to come to a judgement on each
Permit/Deny policy decision by reading and interpreting the full set of access
control rules, and based their judgement on the evidence provided by the
requesting service.

FIWARE [Authzforce](https://authzforce-ce-fiware.readthedocs.io/) is a service
which is able to provide such an interpretive Policy Decision Point (PDP). It is
an advanced access control Generic Enabler which is able to interpret rules
supplied using the
[XACML standard](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=xacml).
Rulesets can be amended and uploaded at any time providing a flexible method to
maintain security policies which can change according to business need.
Furthermore the language used to describe the access policy is designed to be
highly extensible and cover any access control scenario.

## What is XACML

eXtensible Access Control Markup Language (XACML) is a vendor neutral
declarative access control policy language. It was created to promote common
access control terminology and interoperability. The architectural naming
conventions for elements such as Policy Execution Point (PEP) and Policy
Decision Point (PDP) come from the XACML specifications.

XACML policies are split into a hierarchy of three levels - `<PolicySet>`,
`<Policy>` and `<Rule>`, the `<PolicySet>` is a collection of `<Policy>`
elements each of which contain one or more `<Rule>` elements.

Each `<Rule>` within a `<Policy>` is evaluated as to whether it should grant
access to a resource - the overall `<Policy>` result is defined by the overall
result of all `<Rule>` elements processed in turn. Separate `<Policy>` results
are then evaluated against each other using combining alogorthms define which
`<Policy>` wins in case of conflict.

A `<Rule>` element consists of a `<Target>` and a `<Condition>`. This is an
example `<Rule>`, it states access will be granted (`Effect="Permit"`) when a
POST request is sent to the `/bell/ring` endpoint, provided that the
`subject:role` has been provided and that the
`role=security-role-0000-0000-000000000000` :

```xml
<Rule RuleId="alrmbell-ring-0000-0000-000000000000" Effect="Permit">
  <Description>Ring Alarm Bell</Description>
  <Target>
    <AnyOf>
      <AllOf>
        <Match MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
          <AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">/bell/ring</AttributeValue>
          <AttributeDesignator Category="urn:oasis:names:tc:xacml:3.0:attribute-category:resource" AttributeId="urn:thales:xacml:2.0:resource:sub-resource-id" DataType="http://www.w3.org/2001/XMLSchema#string" MustBePresent="true" />
        </Match>
      </AllOf>
    </AnyOf>
    <AnyOf>
      <AllOf>
        <Match MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
          <AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">POST</AttributeValue>
          <AttributeDesignator Category="urn:oasis:names:tc:xacml:3.0:attribute-category:action" AttributeId="urn:oasis:names:tc:xacml:1.0:action:action-id" DataType="http://www.w3.org/2001/XMLSchema#string" MustBePresent="true" />
        </Match>
      </AllOf>
    </AnyOf>
  </Target>
  <Condition>
    <Apply FunctionId="urn:oasis:names:tc:xacml:3.0:function:any-of">
      <Function FunctionId="urn:oasis:names:tc:xacml:1.0:function:string-equal" />
      <AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">security-role-0000-0000-000000000000</AttributeValue>
      <AttributeDesignator Category="urn:oasis:names:tc:xacml:1.0:subject-category:access-subject" AttributeId="urn:oasis:names:tc:xacml:2.0:subject:role" DataType="http://www.w3.org/2001/XMLSchema#string" MustBePresent="false" />
    </Apply>
  </Condition>
</Rule>
```

This is a very verbose method for creating a simple Verb-Resource access rule,
but unlike simple Verb-Resource rules, with XACML, other more complex
comparisons can be made, for example checking that time is before a certain hour
of day, or checking that a URL starts with or contains a certain string.
Conditions can be specified down to the attribute level or combined to make
complex calculations, for example - an XACML `<Rule>` could be created to apply
the following policy:

> _A store manager is able to amend Product prices only the first of the month,
> and can only alter prices of products she or her immediate superior has
> created in the first place_

Such a `<Rule>` would require that the `<Condition>` includes separate
clauses/clarifications for the following:

-   What is the User's role? (e.g. `manager`)
-   What action is being invoked? (e.g PATCH or PUT)
-   Which resource is being protected URL string? (e.g. `/v2/entities`)
-   What other information must be present in the body of the request? (e.g.
    Entity `type` must equal `Product`)
-   When is the resource being requested? (e.g. the current date)
-   What other additional information must be retrieved from elsewhere prior to
    making the request
    -   Who created the entity? Is it me or my manager?

As you can see these rules can quickly become very complex. For this initial
introduction to XACML, the basic rule set used will be kept as simple as
possible to avoid unnecessary confusion, suffice it to say that an access policy
based on XACML can be expanded to fit the security needs of any complex system.

# Prerequisites

## Docker

To keep things simple all components will be run using
[Docker](https://www.docker.com). **Docker** is a container technology which
allows to different components isolated into their respective environments.

-   To install Docker on Windows follow the instructions
    [here](https://docs.docker.com/docker-for-windows/)
-   To install Docker on Mac follow the instructions
    [here](https://docs.docker.com/docker-for-mac/)
-   To install Docker on Linux follow the instructions
    [here](https://docs.docker.com/install/)

**Docker Compose** is a tool for defining and running multi-container Docker
applications. A
[YAML file](https://raw.githubusercontent.com/Fiware/tutorials.Identity-Management/master/docker-compose.yml)
is used configure the required services for the application. This means all
container services can be brought up in a single command. Docker Compose is
installed by default as part of Docker for Windows and Docker for Mac, however
Linux users will need to follow the instructions found
[here](https://docs.docker.com/compose/install/)

## Cygwin

We will start up our services using a simple bash script. Windows users should
download [cygwin](http://www.cygwin.com/) to provide a command-line
functionality similar to a Linux distribution on Windows.

# Architecture

This application adds level 3 Advanced Authorization security into the existing
Stock Management and Sensors-based application created in
[previous tutorials](https://github.com/Fiware/tutorials.Securing-Access/) and
secures access to the context broker behind a
[PEP Proxy](https://github.com/Fiware/tutorials.PEP-Proxy/). It will make use of
five FIWARE components - the
[Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/),the
[IoT Agent for UltraLight 2.0](https://fiware-iotagent-ul.readthedocs.io/en/latest/),
the [Keyrock](https://fiware-idm.readthedocs.io/en/latest/) Identity Manager,
the [Wilma]() PEP Proxy and the
[Authzforce](https://authzforce-ce-fiware.readthedocs.io) XACML Server. All
access control decisions will be delegated to **Authzforce** which will read the
ruleset from a previously uploaded policy domain.

Both the Orion Context Broker and the IoT Agent rely on open source
[MongoDB](https://www.mongodb.com/) technology to keep persistence of the
information they hold. We will also be using the dummy IoT devices created in
the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Sensors/).
**Keyrock** uses its own [MySQL](https://www.mysql.com/) database.

Therefore the overall architecture will consist of the following elements:

-   The FIWARE
    [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) which
    will receive requests using
    [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)
-   The FIWARE
    [IoT Agent for UltraLight 2.0](https://fiware-iotagent-ul.readthedocs.io/en/latest/)
    which will receive southbound requests using
    [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) and convert
    them to
    [UltraLight 2.0](https://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual)
    commands for the devices
-   FIWARE [Keyrock](https://fiware-idm.readthedocs.io/en/latest/) offer a
    complement Identity Management System including:
    -   An OAuth2 authentication system for Applications and Users
    -   A site graphical frontend for Identity Management Administration
    -   An equivalent REST API for Identity Management via HTTP requests
-   FIWARE [Authzforce](https://authzforce-ce-fiware.readthedocs.io/) is a XACML
    Server providing an interpretive Policy Decision Point (PDP) access to the
    **Orion** and/or **IoT Agent** microservices
-   FIWARE [Wilma](https://fiware-pep-proxy.rtfd.io/) is a PEP Proxy securing
    access to the **Orion** microservices, it delegates the passing of
    authorisation decisions to **Authzforce** PDP
-   The underlying [MongoDB](https://www.mongodb.com/) database :
    -   Used by the **Orion Context Broker** to hold context data information
        such as data entities, subscriptions and registrations
    -   Used by the **IoT Agent** to hold device information such as device URLs
        and Keys
-   A [MySQL](https://www.mysql.com/) database :
    -   Used to persist user identities, applications, roles and permissions
-   The **Stock Management Frontend** does the following:
    -   Displays store information
    -   Shows which products can be bought at each store
    -   Allows users to "buy" products and reduce the stock count.
    -   Allows authorized users into restricted areas, it also delegates
        authoriation decisions to the **Authzforce** PDP
-   A webserver acting as set of
    [dummy IoT devices](https://github.com/Fiware/tutorials.IoT-Sensors) using
    the
    [UltraLight 2.0](https://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual)
    protocol running over HTTP - access to certain resources is restricted.

Since all interactions between the elements are initiated by HTTP requests, the
entities can be containerized and run from exposed ports.

![](https://fiware.github.io/tutorials.XACML-Access-Rules/img/architecture.png)

The specific architecture of each section of the tutorial is discussed below.

## Keyrock Configuration

```yaml
keyrock:
    image: fiware/idm
    container_name: fiware-keyrock
    hostname: keyrock
    networks:
        default:
            ipv4_address: 172.18.1.5
    depends_on:
        - mysql-db
        - authzforce
    ports:
        - "3005:3005"
    environment:
        - DEBUG=idm:*
        - DATABASE_HOST=mysql-db
        - IDM_DB_PASS_FILE=/run/secrets/my_secret_data
        - IDM_DB_USER=root
        - IDM_HOST=http://localhost:3005
        - IDM_PORT=3005
        - IDM_ADMIN_USER=alice
        - IDM_ADMIN_EMAIL=alice-the-admin@test.com
        - IDM_ADMIN_PASS=test
        - IDM_PDP_LEVEL=advanced
        - IDM_AUTHZFORCE_ENABLED=true
        - IDM_AUTHZFORCE_HOST=authzforce
        - IDM_AUTHZFORCE_PORT=8080
    secrets:
        - my_secret_data
```

The `keyrock` container is a web application server listening on a single port:

-   Port `3005` has been exposed for HTTP traffic so we can display the web page
    and interact with the REST API.

The `keyrock` container is connecting to **Authzforce** and is driven by
environment variables as shown:

| Key                    | Value        | Description                                                                  |
| ---------------------- | ------------ | ---------------------------------------------------------------------------- |
| IDM_PDP_LEVEL          | `advanced`   | Flag indicating that **Keyrock** should delegate PDP decisions to Authzforce |
| IDM_AUTHZFORCE_ENABLED | `true`       | Flag indicating that **Authzforce** is available                             |
| IDM_AUTHZFORCE_HOST    | `authzforce` | This is URL where the **Authzforce** is found                                |
| IDM_AUTHZFORCE_PORT    | `8080`       | Port that **Authzforce** is listening on                                     |

The other `keyrock` container configuration values described in the YAML file
have been described in previous tutorials

## PEP Proxy Configuration

```yaml
orion-proxy:
    image: fiware/pep-proxy
    container_name: fiware-orion-proxy
    hostname: orion-proxy
    networks:
        default:
            ipv4_address: 172.18.1.10
    depends_on:
        - keyrock
        - authzforce
    ports:
        - "1027:1027"
    expose:
        - "1027"
    environment:
        - PEP_PROXY_APP_HOST=orion
        - PEP_PROXY_APP_PORT=1026
        - PEP_PROXY_PORT=1027
        - PEP_PROXY_IDM_HOST=keyrock
        - PEP_PROXY_HTTPS_ENABLED=false
        - PEP_PROXY_IDM_SSL_ENABLED=false
        - PEP_PROXY_IDM_PORT=3005
        - PEP_PROXY_APP_ID=tutorial-dckr-site-0000-xpresswebapp
        - PEP_PROXY_USERNAME=pep_proxy_00000000-0000-0000-0000-000000000000
        - PEP_PASSWORD=test
        - PEP_PROXY_PDP=authzforce
        - PEP_PROXY_AUTH_ENABLED=true
        - PEP_PROXY_MAGIC_KEY=1234
        - PEP_PROXY_AZF_PROTOCOL=http
        - PEP_PROXY_AZF_HOST=authzforce
        - PEP_PROXY_AZF_PORT=8080
```

The `orion-proxy` container is an instance of FIWARE **Wilma** listening on port
`1027`, it is configured to forward traffic to `orion` on port `1026`, which is
the default port that the Orion Context Broker is listening to for NGSI
Requests.

The `orion-proxy` container is delegating PDP decisions to **Authzforce** and is
driven by environment variables as shown:

| Key                    | Value        | Description                                               |
| ---------------------- | ------------ | --------------------------------------------------------- |
| PEP_PROXY_PDP          | `authzforce` | Flag ensuring that the PEP Proxy uses Authzforce as a PDP |
| PEP_PROXY_AZF_PROTOCOL | `http`       | Flag to enable use of the XACML PDP                       |
| PEP_PROXY_AZF_HOST     | `authzforce` | This is URL where the **Authzforce** is found users       |
| PEP_PROXY_AZF_PORT     | `8080`       | Port that **Authzforce** is listening on                  |

The other `orion-proxy` container configuration values described in the YAML
file have been described in previous tutorials

## Authzforce Configuration

```yaml
authzforce:
    image: fiware/authzforce-ce-server
    hostname: authzforce
    container_name: fiware-authzforce
    networks:
        default:
            ipv4_address: 172.18.1.12
    ports:
        - "8080:8080"
    volumes:
        - ./authzforce/domains:/opt/authzforce-ce-server/data/domains
```

The `authzforce` container is listening on port `8080`, where it receives
requests to make PDP decisions. A volume has been exposed to upload a
pre-configured domain so that a set of XACML access control policies has already
been supplied.

## Tutorial Security Configuration

```yaml
tutorial:
    image: fiware/tutorials.context-provider
    hostname: tutorial
    container_name: fiware-tutorial
    networks:
        default:
            ipv4_address: 172.18.1.7
    expose:
        - "3000"
        - "3001"
    ports:
        - "3000:3000"
        - "3001:3001"
    environment:
        - "DEBUG=tutorial:*"
        - "WEB_APP_PORT=3000"
        - "KEYROCK_URL=http://localhost"
        - "KEYROCK_IP_ADDRESS=http://172.18.1.5"
        - "KEYROCK_PORT=3005"
        - "KEYROCK_CLIENT_ID=tutorial-dckr-site-0000-xpresswebapp"
        - "KEYROCK_CLIENT_SECRET=tutorial-dckr-site-0000-clientsecret"
        - "CALLBACK_URL=http://localhost:3000/login"
        - "AUTHZFORCE_ENABLED=true"
        - "AUTHZFORCE_URL=http://authzforce"
        - "AUTHZFORCE_PORT=8080"
```

The `tutorial` container is listening on two ports:

-   Port `3000` is exposed so we can see the web page displaying the Dummy IoT
    devices.
-   Port `3001` is exposed purely for tutorial access - so that cUrl or Postman
    can make UltraLight commands without being part of the same network.

The `tutorial` container is now secured by **Authforce**, and is driven by
environment variables as shown:

| Key                | Value               | Description                                         |
| ------------------ | ------------------- | --------------------------------------------------- |
| AUTHZFORCE_ENABLED | `true`              | Flag to enable use of the XACML PDP                 |
| AUTHZFORCE_URL     | `http://authzforce` | This is URL where the **Authzforce** is found users |
| AUTHZFORCE_PORT    | `8080`              | Port that **Authzforce** is listening on            |

The other `tutorial` container configuration values described in the YAML file
have been described in previous tutorials

# Start Up

To start the installation, do the following:

```console
git clone git@github.com:Fiware/tutorials.XACML-Access-Rules.git
cd tutorials.XACML-Access-Rules

./services create
```

> **Note** The initial creation of Docker images can take up to three minutes

Thereafter, all services can be initialized from the command-line by running the
[services](https://github.com/Fiware/tutorials.XACML-Access-Rules/blob/master/services)
Bash script provided within the repository:

```console
./services start
```

> :information_source: **Note:** If you want to clean up and start over again
> you can do so with the following command:
>
> ```console
> ./services stop
> ```

### Dramatis Personae

The following people at `test.com` legitimately have accounts within the
Application

-   Alice, she will be the Administrator of the **Keyrock** Application
-   Bob, the Regional Manager of the supermarket chain - he has several store
    managers under him:
    -   Manager1
    -   Manager2
-   Charlie, the Head of Security of the supermarket chain - he has several
    store detectives under him:
    -   Detective1
    -   Detective2

| Name       | eMail                     | Password |
| ---------- | ------------------------- | -------- |
| alice      | alice-the-admin@test.com  | `test`   |
| bob        | bob-the-manager@test.com  | `test`   |
| charlie    | charlie-security@test.com | `test`   |
| manager1   | manager1@test.com         | `test`   |
| manager2   | manager2@test.com         | `test`   |
| detective1 | detective1@test.com       | `test`   |
| detective2 | detective2@test.com       | `test`   |

The following people at `example.com` have signed up for accounts, but have no
reason to be granted access

-   Eve - Eve the Eavesdropper
-   Mallory - Mallory the malicious attacker
-   Rob - Rob the Robber

| Name    | eMail               | Password |
| ------- | ------------------- | -------- |
| eve     | eve@example.com     | `test`   |
| mallory | mallory@example.com | `test`   |
| rob     | rob@example.com     | `test`   |
